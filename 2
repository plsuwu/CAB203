#!/usr/bin/env python

import graphs
import digraphs
import csv

from functools import reduce
from typing import Tuple

# 1. determine whether the tournament structure has the required properties:
#
#   a) for each distinct player, either they play against each other, or there are (minimum) two
#       other players that they BOTH play against.
#
#   b) all players have the same number of games.
#
# {(0, 1), (2, 3), (1, 2), (4, 0), (3, 4)}
#
# (0, 1)
# (2, 3)
# (1, 2)
# (4, 0)
# (3, 4)
def gamesOK(games: set) -> bool:
    # each `Tournament` is defined by a set of Bonkers games `G`, a set of players `P`
    #
    # each game `g` is played by a player and their opponent, `(p,o)`, where the game `(p,o)`
    #   is the same as `(o,p)` and `p` is any player from the set of players `P`
    #   and their opponent `o` is any player in `P` other than `p` such that `o != p`.
    #
    # a 'valid' tournament must contain games `G` such that any player `p` plays the same number
    #   of games `Pg` as any opponent `o` such that any `|Pg(p,o)| == |Pg(o,o)|`.
    #
    # a 'valid' tournament must contain games where all players `p` play against all other
    #   opponents `o` at least once, or play against a minimum of two opponents such that
    #   !(p1,p2) -> ((p1,o1) and (p1,o2)) and ((p2,o1) and (p2,o2))

    # number of unique vertices is the set of all p in {(p,o) | (o,p)}
    S = {a for (a, b) in games} | {b for (a, b) in games}
    E = games | {(a, b) for (b, a) in games}  # all possible edges 2|E|

    # unique vertices x that forms an edge with any u in S
    N = {x: {u for (v, u) in E if v == x} for (x, y) in E}

    # number of edges containing both v and any vertex u in S
    d = {len(N[u]) for u in S}

    # invalid if there is a differing number of edges for any u in N
    if len(d) != 1:
        return False

    # ----------------------------------------------------
    # i feel like there is a better way to write this code
    # ----------------------------------------------------
    # if (u,v) is not an edge in E, determine the intersect for non-(u,v) edges that
    # contain either u or v as a vertex
    #
    # valid if the length of this intersect is >= 2, otherwise invalid
    e = all((len(N[v] & N[u])) >= 2 for u in S for v in S if v != u and u not in N[v])

    return e


def referees(games: set[Tuple[str,str]], refereecsvfilename: str) -> (dict[Tuple[str, str], str] | None):

    # Referee,  Conflict1,  Conflict2,  Conflict3,  Conflict4
    # Joe,      Ashley,     Bob,        Charlie,    Ellie
    # Rene,     Charlie,    David,      Ellie
    # David,    Elaine,     Alice,      Ellie

    # games = {
    #   (joe, charlie)
    #   (bob, alice)
    #   (ellie, rene)
    # }
    # with open(refereecsvfilename, newline="") as f:
    #     reader = csv.reader(f)

        # parse the csv into a dictionary of each referee and a set of the referee's conflicts
        # discard the header column
    with open(refereecsvfilename, newline="") as f:
        reader = csv.reader(f)

        # parse the csv into a dictionary of each referee and a set of the referee's conflicts
        # discard the header column
        # referee_conflicts = { row[0]: set(row[1:]) for row in reader if row[0] != "Referee" }
        # checker = { game: ref for ref in referee_conflicts.keys() for game in games if ref not in set( { v for (v,u) in games } | { v for (u,v) in games })}



        conflicts = { row[0]: set(row[1:]) for row in reader if row[0] != "Referee" }
        V = { r for r in conflicts.keys() } | { p for (p,o) in games } | { o for (p,o) in games }

        print('games-> ', games ,'\n')
        print('r -> ', { r for r in conflicts.keys() } )
        print('r_c -> ', conflicts)
        print('V -> ', V)

        def assignable(r, u, c):
            return all(v not in c[r] for v in u and r not in u)

        def graph(E, c):
            def e(g):
                return [filter(
                        lambda r: assignable(r, g, c),
                        conflicts.keys()
                    )]

        def bipart_match(g, G, m_r, seen):
            def try_match(r):
                if r not in seen:
                    seen.add(r)
                    if r not in m_r or bipart_match(m_r[r], G, m_r, seen):
                        m_r[r] = g
                        return True
                return False

            return any(map(try_match, graph[game]))

        def match(G):
            match_r = {}
            match_l = {}
            { bipart_match(g, G, match_r, seen = set()) for g in games }
            match_l = { m_r[ref]: ref for ref in match_r }
            return match_l


        G = graph(games,conflicts)
        max = match(graph)

        print(max)
        # assigned = set()

        # print(E)
        # return E

        # print('{referees_a: { conflict_a, conflict_b, ... }}-> ', referee_conflicts, '\n')



        # return checker if checker != {} else None
    # checker = { game: ref for ref in referee_conflicts.keys() for game in games if ref not in set( { v for (v,u) in games } | { v for (u,v) in games })}



        #
        # # find all players and their opponents as a set of vertices V
        # V = { u for (u,v) in games } | { v for (u,v) in games }




def gameGroups(assignedReferees):
    pass


def gameSchedule(assignedReferees, gameGroups):
    pass


def scores(p, s, c, games):
    pass
